# 数据库

## 数据库基础

### 事物特性？

ACID

- Atomicity**原子性**：数据库事务是不可分割的工作单位，只有事务中的所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL执行失败，已经执行成功的SQL语句也必须撤销，回到执行事务的之前的状态。
- Consistency**一致性**：事务将数据库由一种一致性状态转为下一种一致性状态。事务开始前后，数据库完整性约束没被破坏。例：转账前后，账户余额的总和保持一致。
- Isolation**隔离性**：每个读写事务对其他事务的操作对象能相互分离。
- Durability**持久性**：事务一旦提交，结果被永久改变，即使出现故障也保持。



### 事务隔离级别？

主要在多个事务并发的情况下。解决脏读、不可重复读、幻读等问题。

- Read uncommitted 读未提交
  - 脏读：事务B读取了事务A尚未提交的数据，即事务A还未结束就回滚的数据被事务B读到。
- Read committed 读提交
  - 不会出现脏读，但会出现不可重复读。
  - 不可重复读：事务A读取数据后，事务B紧接更新了数据并提交事务，事务A再次读取的时候，数据已经被修改。
  - SQL Server、Oracle默认级别
- Repeatable read 重复读
  - 避免不可重复读。一个事务中重复读取数据，不会发生变化，除非提交了数据，再次进行读取
  - 幻读：事务A查询了数据，此时事务B新增一条数据。事务A继续新增这条数据时发现冲突，或者更新时影响的行数跟刚刚读取的不一致。
- Serializable 串行化
  - 最高的事务隔离级别。
  - 事务顺序执行，避免脏读、不可重复读、幻读。
  - 性能很低，很少使用。



## MySQL

### 索引

| 索引              | InnoDB        | MyISAM引擎 | Memory引擎 |
| :---------------- | ------------- | ---------- | ---------- |
| B-Tree索引        | 支持          | 支持       | 支持       |
| Hash索引          |               |            | 支持       |
| R-Tree索引        |               | 支持       |            |
| 全文索引Full-text | 5.6版本后支持 | 支持       |            |

### B-Tree结构？

- 又叫多路平衡搜索树，$m$叉的B-Tree性质：
  - 每个节点最多有$m$个子节点
  - 除了根节点和叶节点，每个节点至少有$[ceil(m/2)]$个子节点
  - 如果根节点不是叶节点，至少有两个子节点
  - 所有叶节点都在同一层
  - 每个非叶节点由$n$个key和$n+1$个指针组成。$[ceil(m/2) - 1] <= n <= m - 1$

### B+Tree结构？

区别：

- n叉B+Tree最多有n个key，BTree最多有n-1个key
- B+Tree叶节点保存所有key信息，按key顺序大小排列
- 所有非叶节点都可以看做key的索引部分

只有叶节点保存key信息，查询任何key都要从根节点走到叶节点，因此查询效率稳定。

MySQL中对B+Tree进行了优化，在叶节点中增加了指向相邻叶节点的链表指针，提高区间访问的性能。

### 索引分类？

- 单值索引：一个索引只包含单个列，一个表中可以有多个单值索引
- 唯一索引：索引的值必须唯一，允许有空值
- 复合索引：一个索引包含多个列

### 索引设计原则？

- 频繁作为查询条件的字段应该建立索引（`where` 子句内的字段）
- 唯一性太差也就是重复性太高的字段不适合建立索引（比如性别）
- 字段更新比查询频繁很多的字段不适合
- 不会出现在 `where` 子句内的字段不应该建立索引
- 使用短索引，对于较长的字符串列可以指定前缀长度，节省空间，提高速度
- 最左前缀原则

### 最左前缀原则？

MySQL的索引可以引用多列，叫做联合索引。当一个查询条件可以匹配联合索引的前面一列或者多列，就可以命中索引。

```mysql
ALTER TABLE user ADD INDEX name_city_index (name, city) // 建立了联合索引
select * from user where name=xx and city=xx ; // 可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引  
```

因此在建立联合索引时，要考虑将常用查询语句中重复较多的字段放在前面。

### 覆盖索引？

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

### 查询语句优化？

