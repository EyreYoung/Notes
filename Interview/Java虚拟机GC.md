# Java虚拟机/垃圾回收

## JVM

### JVM调优

如果CPU使用率较高，GC频繁且GC时间长，可能就需要JVM调优了。
 基本思路就是让每一次GC都回收尽可能多的对象，
 对于CMS来说，要合理设置年轻代和年老代的大小。该如何确定它们的大小呢？这是一个迭代的过程，可以先采用JVM的默认值，然后通过压测分析GC日志。

如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。

如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。

对于G1收集器来说，可以适当调大Java堆，因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。

## GC

### GC算法

- 引用计数法。对于对象A，任何对象引用了A，它的引用计数器+1，引用失效-1。引用计数器变成0的时候，不能再使用
- 标记-清除算法（Mark-Sweep）。标记阶段通过根节点标记可达对象。未被标记则是垃圾对象。容易造成内存碎片化
- 复制算法。内存分为两块，一半放数据，另一半不放。GC时将正在使用的内存的存活对象拷贝到未使用的内存块，清楚原来的所有对象。有内存浪费
- 标记-压缩。先标记对象，把不可回收的对象放到已回收的对象的位置。没有内存浪费

### 老生代和新生代？

- 新生代分为eden、survivor1、survivor2。new的对象非常大则放入老生代，否则放入edan，GC一次后仍有引用，放入survivor1，再经历一次放入survivor2.一定次数后放入老生代。