# Java锁

Java多线程的锁都是基于对象的，类锁也是特殊的对象锁，Java类只有一个Class对象，可以有多个实例对象共享这一个Class对象，类锁就是这个Class对象的锁

## volatile

[Java程序员面试必备：Volatile全方位解析](https://juejin.im/post/6859390417314512909)

- 修饰符，只修饰变量
- 最轻量级的同步机制

## synchronized

### 实现原理

- 线程的执行代码进入synchronized代码块前会自动获取内部锁，其他线程访问该同步代码块会被阻塞挂起。
- 拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者同步块中调用了wait系列方法时释放该内置锁
- 阻塞线程时会将用户态切换到内核态执行阻塞操作。会导致上下文切换

### 内存语义

- 把在synchronized块内使用到的变量从线程的工作内存中清除，这样使用到该变量时直接从主内存中获取
- 退出synchronized块把在synchronized块中对共享变量的修改刷新到主内存

### 使用方式

```java
// 锁实例
public synchronized void instanceLock() {
    // TODO
}

// 锁class对象
public static synchronized void classLock() {
    // TODO
}

public void blockLock() {
    Object o = new Object();
    // 锁对象o
    synchronized (o) {
        // TODO
    }
    
    // 锁实例
    synchronized (this) {
        // TODO
    }
    
    // 锁class对象
    synchronized (this.getClass()) {
        // TODO
    }
}
```

### 锁升级

Java6之前所有锁都是重量级锁

Java6后对象有四种锁状态：**无锁**/**偏向锁**/**轻量级锁**/**重量级锁**

**锁对比**：

| 锁       | 优点                           | 缺点                                     | 适用场景                                 |
| -------- | ------------------------------ | ---------------------------------------- | ---------------------------------------- |
| 偏向锁   | 加锁解锁不需要额外消耗，速度快 | 如果线程间存在锁竞争，会导致锁撤销的消耗 | 只有一个线程访问同步块，几乎不存在锁竞争 |
| 轻量级锁 | 竞争的线程不会阻塞，响应速度快 | 如果竞争的线程一直自旋会消耗CPU          | 追求响应时间；同步块的执行速度非常快     |
| 重量级锁 | 线程竞争不会自旋，不会消耗CPU  | 线程阻塞，响应速度慢                     | 追求吞吐量。同步块执行速度慢             |



#### Java对象头

- 每个Java对象都有对象头。非数组类型用2个字宽存储，数组类型用3个字宽（虚拟机位数大小）
- 对象头内容：

| 长度                 | 内容                   | 说明                   |
| -------------------- | ---------------------- | :--------------------- |
| 32/64bit             | Mark Word              | 对象的hashCode或锁信息 |
| 32/64bit             | Class Metadata Address | 到对象类型数据的指针   |
| 32/64bit（数组情况） | Array Length           | 数组长度               |

- Mark Word内容

| 锁状态   | 29bit或61bit                                | 1bit 是否是偏向锁 | 2bit 锁标志位 |
| -------- | ------------------------------------------- | ----------------- | ------------- |
| 无锁     |                                             | 0                 | 01            |
| 偏向锁   | 线程ID                                      | 1                 | 01            |
| 轻量级锁 | 指向栈中锁记录Lock Record的指针             | 不使用            | 00            |
| 重量级锁 | 指向互斥量（重量级锁）堆中Monitor对象的指针 | 不使用            | 10            |
| GC标记   |                                             | 不使用            | 11            |

#### 偏向锁

大部分锁不存在多线程竞争，而且总是由同一线程多次获得

- 线程第一次进入同步块时，在对象头和栈帧的锁记录里存储锁的偏向的线程ID
- 该线程下次进入这个同步块的时候，会去检查锁的Mark Word里放的是不是自己的线程ID
- 是的话，表明该线程已经获得了锁。以后该线程在进入和退出同步块时不需要花费CAS操作来加锁解锁
- 不是的话，表明有另一个线程来竞争这个偏向锁。使用CAS替换Mark Word里的线程ID为新的线程ID
- 成功的话表示之前的线程不存在了，锁不会升级，仍然为偏向锁
- 失败表示之前的线程仍然存在，暂停偏向锁线程，将锁升级成轻量级锁，并竞争

![](img/偏向锁流程.png)

#### 轻量级锁

多个线程在不同时段获取同一把锁，不存在锁竞争的情况，也就没有线程阻塞。JVM使用轻量级锁避免线程的阻塞和唤醒

- 每个线程在栈帧中创建用于存储锁记录的空间：Displaced Mark Word
- 线程获得锁的时候发现是轻量级锁，则把锁的Mark Word复制到自己的Displaced Mark Word里
- 线程尝试用CAS把锁的Mark Word替换为指向锁记录的指针
- 成功则线程获得锁
- 失败则表示Mark Word已经被替换为其他线程的锁记录，当前线程就尝试自旋获取锁
- 适应性自旋：线程自旋成功，则下次自旋次数更多，失败则减少
- 自旋到一定程度，仍然没有获取到锁，锁会升级成重量级锁

![](img/轻量级锁流程图.png)

#### 重量级锁

- 以来操作系统的互斥量实现（mutex）
- 锁对象的Mark Word为指向一个堆中monitor对象的指针
  - Contention List：所有请求锁的线程将被首先放置到该竞争队列
  - Entry List：可以成为候选人的线程被移到Entry List
  - Wait Set：调用wait被阻塞的线程被放到Wait Set
  - OnDeck：任何时刻最多有一个线程竞争锁，称作OnDeck
  - Owner：获得锁的线程
  - ！Owner：释放锁的线程
- 线程释放锁时，从Contention List和Entry List中选择一个线程唤醒作为假定继承人。
- 假定继承人被唤醒后会尝试获得锁，但重量级锁中，线程先自旋尝试获得锁，失败再进入等待队列，因此不公平
- 调用锁对象的wait和notify时，锁如果是偏向锁或者轻量级锁会先膨胀成重量级锁

#### 锁升级流程

1. 准备获取资源时，先检查MarkWord中是否是自己的Thread ID，是的话，表示现在处于偏向锁
2. 如果Mark Word不是自己的Thread ID，锁升级。使用CAS执行切换，新线程根据MarkWord里现有的Thread ID，通知之前的线程暂停，之前线程将MarkWord内容置为空
3. 两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间。通过CAS操作把锁的MarkWord内容改为自己新建的记录空间的地址，竞争Mark Word
4. 成功CAS的获得资源，失败的进入自旋
5. 自旋的线程在自旋过程中获得资源，则整个状态仍然是轻量级锁，失败则进入重量级锁状态
6. 自旋的线程进入阻塞，等待之前的线程执行完成后唤醒自己

#### 锁粗化

虚拟机将多次连接在一起的加锁解锁操作合并，将多个连续的锁扩展成一个范围更大的锁

#### 锁消除

删除不必要的加锁操作。如果判断一段代码中，堆上数据不会逃逸出当前线程，认为不必要加锁

## 杂项

### `Synchronized` 和 `lock` ？

- `Synchronized` 是Java中的关键字，用来修饰一个代码块或一个方法。

```java
public int synMethod(int m){
  synchronized(m) { // 括号后是变量，一次只有一个线程进入代码块
    //...
  }
}

public synchronized void synMethod() { // 一次只有一个线程进入该方法
   //...
}

public void test() { 
  synchronized (this) { // 括号内放入对象，线程获得对象锁
      //...
  }
}
```

- `Lock` 是接口，有如下方法：

```java
public interface Lock {
  void lock(); // 用来获取锁，必须主动释放锁，发生异常时不自动释放，因此要放在try catch中，释放锁放在finally中，防止死锁
  void lockInterruptibly() throws InterruptedException; // 获取锁时，如果锁被占用，可以响应中断状态
  boolean tryLock(); // 有返回值，获取锁成功返回true，被占用返回false。无论如何立即返回，拿不到锁不会一直等待
  boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 类似tryLock，等待时间内获取到锁返回true，超时返回false
  void unlock(); // 释放锁，一定要在finally块中
  Condition newCondition();
}
```

- 发生异常时，`Synchronized`会自动释放线程占用的锁。`Lock`假如没有使用 `unlock()` 的话会造成死锁
- `Synchronized`不能响应中断，因此会一直等待。`Lock`可以响应中断状态
- `Lock` 可以知道是否成功获取锁，`Synchronized`不能
- `Synchronized`是非公平锁，无法实现公平锁。`ReentrantLock`两个都可以实现

### `volatile` ？

- 保证变量操作的**可见性**。一个线程修改了变量值，立刻写入到物理内存中，其他线程中已经写入的值宣布无效，重新从物理内存中加载
- 保证变量操作的**有序性**。禁止指令重排序。
- **不保证原子性**。比如线程1已经计算出了临时变量还未赋值，因此没能写到物理内存，此时线程二修改了变量，线程1之后继续把已计算的临时变量继续赋值
- 加入 `volatile`的变量在汇编代码中加入了`lock`指令，相当于一个内存屏障

### `synchronized` 修饰静态方法和成员方法分别锁住了什么？

- 修饰普通成员方法时，锁是对象锁(this)。
  - 当一个类中多个普通方法被`synchronized`修饰（同步），锁的都是这个类的对象this。多个线程访问同一个类的不同方法也会被阻塞。
  - 如果通过不同对象来调用，锁就是不一样的，不会阻塞。
  - 通过同一个对象调用非同步方法不会被阻塞
- 修饰静态方法时，是类锁。范围比对象锁大。只要是该类的对象，使用的都是同一把锁。

### CAS？

- **CompareAndSwap**。内存地址v，旧的预期值A，更新目标值B
- **乐观锁**的一种。拿数据时认为别人不会修改。更新数据的时候判断是否被修改过。
- 多个线程更新同一个变量时，一个会成功，其他不成功并重试
- 循环时间长，失败不断重试，给CPU带来压力
- 只能保证一个共享变量的原子操作
- **ABA问题**。修改为B后又修改为A，无法判断中间发生过修改。J.U.C包提供一个带标记的原子引用类 `AtomicStampedReference` 解决，通过控制变量值的版本保证CAS准确性

### Atomic

- 轻量级地保证变量原子性
- 通过无锁化的CAS实现