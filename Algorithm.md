# 算法设计与分析

---

## 算法基本概念

### 算法特性

- 确定性

- 能行性

- 输入

- 输出

- 有穷性

### 渐进时间复杂度
1. $T(n) = O(f(n))$上界

2. $T(n) = Ω(f(n))$下界

3. $T(n) = Θ(f(n))$确界

## 排序算法

### 插入排序 

```python
def insertsort(A):
    for index in range(1, len(A)):
        key = A[index]
        i = index - 1
        while i >= 0 and A[i] > key:
            A[i + 1] = A[i]
            i = i - 1
        A[i + 1] = key
    return A
```

最坏情况：数组顺序与要求顺序正好相反

最坏时间复杂度：$θ(n^2)$

### 合并排序

---

## 递归算法

### 概念

递归函数：用函数自身给出定义的函数

递归算法：一个算法包含对自身的调用

### 问题实例

#### Fibonacci数列

```python
def fibonacci(n):
    if n <= 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
```

#### 整数划分问题

将正整数$n$表示成一系列正整数之和:$n=n_1+n_2+...+n_k 其中n_1\geq n_2\geq ...\geq n_k\geq 1,k\geq 1$

求正整数$n$的不同划分个数$p(n)$

$p(5)=7$

$q(n, m)=$



```python
// 引入m，最大加数不大于m
def q(n, m):
    if n < 1 or m < 1:
        return 0
    if n == 1 or m == 1:
        return 1
    if n < m:
        return q(n, n)
    if n == m:
        return 1 + q(n, n -1)
    if n > m > 1:
        return q(n, m - 1) + q(n - m, m)
```

#### 汉诺塔问题




### 解法

#### 代换法

**步骤**

1. 猜测解的形式

2. 用数学归纳法证明之

**适用于**解的形式容易猜

#### 递归树解法

#### 主方法

$T(n)=aT(\frac n b)+f(n)$

$a\geq 1,b>1,f(n)为渐进正函数$

规模为$n$的问题，分解成$a$个子问题，每个子问题规模为$\frac n b$ ，问题分解和合并代价为$f(n)$

**主定理**

$T(n)$有如下渐进界

对递归式，比较$f(n)$和$n^{log_b a}$

1. 如果$f(n)=O(n^{log_b a-ε})$，则$T(n)=Θ(n^{log_b a})$

eg:$T(n)=9T(\frac n 3)+n$

$a=9,b=3,f(n)=n,n^{log_b a}=Θ(n^2),f(n)=n\leq Θ(n^2)$

$T(n)=Θ(n^2)$

2. 如果$f(n)=Θ(n^{log_b a})$，则$T(n)=Θ(n^{log_b a}lg n)$
3. 如果$f(n)=Ω(n^{log_b a+ε})$，则$T(n)=Θ(f(n))$

---


## 分治法

### 概念

#### 基本策略

1. **分解**：将原问题分解为子问题
2. **解决**：求解子问题
3. **合并**：组合子问题的解

#### 适用条件

1. 问题规模缩小就能解决
2. **最优子结构性质**：可以分解为若干小规模的相同问题
3. 子问题的解可以合并
4. 没有公共子问题（子问题相互独立）

#### 平衡

使子问题规模接近

分治和递归时，尽量把问题分为规模相近的子问题以提高算法效率

### 问题实例

#### 二分搜索

**问题**：已排序的数组中查找特定元素

**分解**：检查中间元素

**解决**：递归搜索子数组

**合并**：pass

**分析**：$T(n)=1T(\frac n 2)+Θ(1)$，$T(n)=Θ(lgn)$

#### 快速排序

```python
def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q - 1)
        quicksort(A, q + 1, r)
    return A


def partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i = i + 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1
```

#### 最大元最小元

**问题**：给定$n$个元素，找出其中最大元和最小元

```python
def maxmin(A):
    if len(A) == 1:
        return A[0], A[0]
    elif len(A) == 2:
        if A[0] > A[1]:
            return A[0], A[1]
        else:
            return A[1], A[0]
    else:
        A1 = A[ : (len(A) // 2)]
        A2 = A[(len(A) // 2) : ]
        max1, min1 = maxmin(A1)
        max2, min2 = maxmin(A2)
        max = max1 if max1 > max2 else max2
        min = min1 if min1 < min2 else min2
        return max, min
```

$T(n)=Ω(3n/2 - 2)$

#### 最近点对

**问题**：平面上给定$N$个点，找出距离最近的两个点

**预处理**：将点对按$X$坐标和$Y$坐标排序

**分解**：按$X$坐标二分点集，返回分解后的按$Y$坐标排序的点集

**解决**：分别求两部分的最近点对

**合并**：找到以宽为$min(d1, d2)$的带状区域的点，计算每个点与后面七个点的距离，更新最近点对距离

#### 寻找顺序统计量

**问题**：输入包含$n$个不同数的集合$A$和数$i$，输出大于$A$中其他$i-1$个元素的元素$x$

**分解**：用`partition()`分割数组

**求解**：分割的书序号恰好为$i$

**合并**：递归处理$i$所在数组范围

```python
def randselect(A, p, q, i):
    if p == q:
        return A[p]
    r = partition(A, p, q)
    k = r - p + 1
    if i == k:
        return A[r]
    elif i < k:
        return randselect(A, p, r - 1, i)
    else:
        return randselect(A, r + 1, q, i - k)


def partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i = i + 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1
```

一般情况：$T(n)=Θ(n)$

最坏情况：$T(n)=Θ(n^2)$

---

## 动态规划

### 概念

#### 总体思想

保存已解决的子问题的答案，在需要时使用，防止大量重复计算

#### 适用范围

1. 问题可以分解为若干**高度重复**的子问题
2. 问题具有**最优子结构性质**

#### 解题步骤

1. 找出最优解的性质，刻画解的结构特征
2. 递归地定义最优值（写出动态规划方程）
3. 自底向上递推计算出最优值
4. 根据计算最优值时得到的信息，递推构造最优解

#### 备忘录方法

问题可以用动态规划求解，但是数组中一部分元素在计算时不会被用到

数组中元素只在需要计算时去计算，计算采用递归，计算后保存

### 问题实例

#### 矩阵连乘

**问题**：求出矩阵连乘所需最少乘法次数

```python
def matrixchain(p, n, m, s):
    for i in range(1, n + 1):
        m[i][i] = 0
    for r in range(2, n + 1):
        for i in range(1, n - r + 2):
            j = i + r - 1
            m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j]
            s[i][j] = i
            for k in range(i + 1, j):
                t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]
                if t < m[i][j]:
                    m[i][j] = t
                    s[i][j] = k


def trackback(i, j, s):
    if i == j or i == 6:
        print('A', end = '')
        print(i, end = '')
        return
    print('(', end = '')
    trackback(i, s[i][j], s)
    print(')(', end = '')
    trackback(s[i][j] + 1, j, s)
    print(')', end = '')
```

#### 最长公共子序列LCS

**问题**：序列$X=\{A,B,C,B,D,A,B\}$，则$Z=\{B,C,D,B\}$为其子序列。给出两个序列，找出他们的最长公共子序列。最长公共子序列有时不止一个

**解的性质**：设$X_i=<x_1,......,x_i>$为$X$序列前$i$个字符，$Y_j=<y_1,......,y_j>$为$Y$序列前$j$个字符，$Z=<z_1,......,z_k>\in LCS(X,Y)$

- 如果两个序列最后一个字符相同，那么这个字符一定包含在最长公共子序列中，并且$Z_{k-1}\in LCS(X_{m-1},Y_{n-1})$
- 如果最后的字符不同，$Z_k$与$X_m$不同，那么$Z\in LCS(X_{m-1},Y)$，对于$Y$序列同理
- 求$LCS(X_{m-1},Y)$和$LCS(X,Y_{n-1})$时，具有重叠性
- 序列的$LCS$包含了序列前缀的$LCS$，因此具有最优子结构性质

#### 最大子段和

#### 流水作业调度

**问题**：$n$个作业，每个作业被分为$m$项任务，任务要安排到$m$台机器上加工

- 每个作业$i$的第$j$项任务$T_{ij}$只能安排在机器$P_j$上加工
- $T_{ij}$开始加工时间必须在$T_{i,j-1}$加工完之后
- 一台机器一个时刻只能进行一个任务

机器数$$m\geq 3$$时，是NP难问题

机器数$m=2$时，有多项式时间算法

**解的性质**：

- 机器$P_1$空闲时，任何作业的第一个任务都能在上面执行
- 最优调度可以使$P_1$的任务无间断
- 并让$P_2$上的加工空闲时间最小
- $P_2$上加工次序与$P_1$上不同时，只可能增加加工时间

**最优调度**：

- 去掉最优调度的第一个作业，剩下的仍然是一个最优调度（最优子结构）
- 计算的子集合的最优调度多次用到（高度重复性）

---

## 贪心算法

### 概念

#### 基本思想

- 总是做出在当前看来最好的选择
- 不从整体最优考虑，只是局部最优选择
- 不能对所有问题得出最优解，但对一部分能够得到
- 有时即使不是最优解，也是最优解的近似

#### 基本要素

**贪心选择性质**：问题的整体最优解可以通过弹性选择来达到

动态规划以自底向上的方法解决子问题，贪心算法以自顶向下的方式迭代，每次贪心选择都将问题变为规模更小的子问题

**最优子结构性质**：问题的最优解包含子问题的最优解

### 问题实例

#### 活动安排问题

**问题**：有$n$个活动的集合，$[s_i,f_i)$表示活动$i$的占用时间区间，两个区间不相交的活动相容，要选出最大相容活动子集合

**解题**：

1. 活动按照结束时间增序排列
2. 先选活动1，检查后面的活动$i$与前面选择的活动是否相容，相容则加入集合$A$，不相容则继续检查下一个活动

```python
#s为起始时间集合，f为结束时间集合
def greedyactivityselect(s, f):
    n = len(s)
    A = [0]
    j = 0
    for i in range(1, n):
        if s[i] >= f[j]:
            A.append(i)
            j = i
    return A
```

$T(n)=Θ(n)$（已按结束时间排序）

$T(n)=O(nlgn)$（未排序）

#### 背包问题

**问题**：$n$种物品，一个背包。物品$i$重量为$W_i$，价值为$V_i$，背包容量为$C$，选择装入的物品，使总价值最大。可以选择物品的一部分

**步骤**：

1. 计算每个物品$i$的单位重量价值$\frac {V_i} {W_i}$
2. 按照贪心策略，尽量把单位重量价值最高的物品装入背包
3. 如果装完了还未达到重量$C$，选择次高的物品尽量装入，直到背包装满

#### 单源最短路径Dijkstra

**策略**：扩充$V-S$点集时选择距离源最近的点

#### Prim

**策略**：选择已选集合和未选集合相连的边中最小的边，然后将点添加到已选集合中

#### Kruskal

**策略**：将图中边按照权重排序，从小到大选择边加入已选集合，如果加入后会在图中形成回路，则去掉这个边，继续查看下一个边

#### Huffman编码

**问题**：按照权重构造最优前缀码

**策略**：从集合(e.g.$\{1,2,3,4,5\}$)中挑选出最小的两个数作为叶节点构造一个三个节点的数，根节点权重为这两个数之和，从几何中删掉这两个数，将和放入集合(e.g.$\{3,3,4,5\}$)，不断重复，最终获得一颗完全二叉树

---

## 随机算法

### 概念

#### 基本思想

- 不要求对所有可能的输入都正确计算
- 要求错误的可能性小到可以忽略
- 不要求对同一输入，每次执行都给出相同的结果

#### 特点

- 对于一些问题，目前只有效率很差的确定性算法，用随机算法可以获得较好的结果

- 实现简单
- 不用构造最坏情况

#### 分类

**Las Vegas算法**：

- 少数情况求不出解
- 一旦找到解，这个解一定正确
- 求不出解时，再次调用算法进行计算

**Sherwood随机化方法**：

- 问题已有平均条件下较好的确定性算法，但在最坏情况下效率低，引入随机数来将其改成随机算法，如**快速排序**
- 如果无法直接使用，可以对输入先进行随机预处理
- 当确定性算法最坏情况与平均情况的时间复杂度有较大差别时，可以引入随机性

**Monte Carlo算法**：

-  不能保证结果正确
- 通过反复执行降低错误概率
- $k$次执行发生错误概率为$(1-p)^k$

### 问题实例

#### 求第$k$小元素

**Las Vegas**

```python
import random

def randselect(S, k):
    S1 = []
    S2 = []
    S3 = []
    n = random.randint(0, len(S) - 1)
    x = S[n]
    for i in range(0, len(S)):
        if S[i] < x:
            S1.append(S[i])
        elif S[i] == x:
            S2.append(S[i])
        else:
            S3.append(S[i])
    if len(S1) >= k:
        return randselect(S1, k)
    elif len(S1) + len(S2) >= k:
        return x
    else:
        return randselect(S3, k - len(S1) - len(S2))
```

比较数的期望值不超过$4n$

#### 字符串比**较**

**Monte Carlo**

**策略**：

1. 若长度不等，则$x\neq y$
2. 若长度相等，先对$x$取指纹发给$B$，并检查$y$的指纹是否相等
3. 取$k$次，次数越多，误判率越低

$P(误匹配)\leq \frac{1}{n^k}$

#### Pattern Matching

**Monte Carlo**

**问题**：$Y$是否为$X$的字串

**算法**：$X(j)=\{X_j,X_{j+1},......,X_{j+m-1}\}$，从第$j$位开始，长度与$Y$一样的子串

从$X(1)$到$X(n-m+1)$，逐一取指纹进行字符串比较

$T(n)=O(m+n)$

**Las Vegas**

$Ip(X(j))=Ip(Y)$时，继续比较$X(j)$和$Y$

出错概率为0 

#### Random Sampling

**Las Vegas**

**问题**：给定$n$个元素，从中随机选取$m$个数

**策略**：用长度同样为$n$的布尔数组$B$标识$i$是否被选中，随机产生$[1,n]$之间的一个整数，如果这个数未选中，则加入选中队列，同时更改$B[i]$，反复执行$m$次

**缺点**：

- $n$和$m$很接近的时候，随机到已选中的数的概率大，效率低。**改进**：$m>\frac {n}{2}$时，反选
- $n\gg m$时，布尔数组浪费空间。**改进**：用允许冲突的散列表存放随机数 

#### 主元素问题

**Monte Carlo**

**问题**：判断数组中是否存在占据总数一半以上的元素

#### 素数测试

**问题**：判断一个数是否为素数

**费尔马小定理**： 如果$n$为素数，且$0<a<n$，有$a^{n-1}\equiv 1(mod\ n)$

**素数判定**：用$2^{n-1}\equiv 1(mod\ n)$判断，如果判断非素数则一定正确，判断是素数则出错概率很小

**二次探测定理**：如果$p$是一个素数，且$0<x<p$，则$x^2\equiv 1(mod\ p)$的解为$x=1,p-1$

#### $n$皇后问题

**问题**：在$n*n$的棋盘上放置$n$个互相不受攻击的皇后棋子

**Las Vegas**

**策略**：在每行随机放置皇后，保证新皇后不与旧皇后冲突，直到放完或者没有位置可放

---

## 回溯法

### 概念

#### 基本思想

- 回溯法的基本做法是搜索，是**避免不必要搜索**的穷举法
- 回溯法在问题的解空间树中按深度优先策略，从根节点出发搜索解空间树
- 算法搜索到解空间树的任意一点时，先判断该节点是否包含问题的解。如果不包含则跳过该子树，逐层向祖先节点回溯
- 适用于求解组合数较大的问**题**
- **具有限界函数的深度优先生成法**

#### 解空间

对问题实例，解向量满足显式约束（对分量的取值限定）的所有多元组，构成实例的一个解空间

#### 解题步骤

1. 针对问题定义解空间
2. 确定易于搜索的解空间结构
3. 深度优先搜索解空间，期间用**剪枝函数**避免无效搜索
4. 搜索到树上某一点时，先判断节点对应部分解是否满足约束条件，是否超出目标函数的界

**剪枝函数**：

- 约束函数在扩展节点剪去不满足约束的子树
- 限界函数剪去得不到最优解的子树